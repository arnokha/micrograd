<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Micrograd MLP Viz 2</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }

        #reporting-container {
            display: block;
            /* justify-content: center; */
        }

        #main-container {
            display: flex;
            width: 100%;
            height: 700px;
        }

        #svg-container {
            flex: 0 0 1200px;
            z-index: 10;
            /* overflow: auto; */
        }

        #right-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        #info-container {
            /* flex: 1; */
            padding: 15px;
            overflow-y: auto;
        }

        #controls-container {
            flex: 1;
            padding: 15px 20px;
            overflow-y: auto;
        }

        #info {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 16px;
            line-height: 1.5;

            height: 250px;
            border-radius: 15px;
            overflow-y: auto;

        }

        #info .katex {
            font-size: 1.2em;
        }

        /*-=-=-=-=-=-=-=-=-=-=-=-=*/
        /* MLP CSS*/
        /*-=-=-=-=-=-=-=-=-=-=-=-=*/
        #network {
            border: 1px solid #ccc;
        }

        #layerDimInput {
            width: 75px;
            font-size: 16px;
            font-weight: 500;
            border: 0;
            background-color: #dbf4ff33;
        }

        #layerDimInput:hover {
            outline: 1px solid navy;
        }

        .layer:hover rect {
            fill: rgb(190, 190, 190);
            fill-opacity: 0.1;
        }

        .latex-label:hover {
            filter: brightness(0.5);
        }

        .latex-label.selected {
            filter: brightness(0.5);
        }

        .layer.selected>rect {
            fill: rgb(190, 190, 190);
            fill-opacity: 0.3;
        }

        /* Connections */
        .connection:hover {
            stroke-width: 3;
            filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.7));
        }

        .connection.positive {
            stroke: rgb(100, 100, 255);
        }

        .connection.negative {
            stroke: rgb(255, 100, 100);
        }

        .connection.selected {
            stroke-width: 3;
            stroke-opacity: 1;
        }

        /* Nodes */
        .node {
            cursor: pointer;
        }

        .node:hover {
            fill: #ffb650;
        }

        .node.selected {
            fill: #ffb650;
        }

        /* MLP actions */
        #button-group-container {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }

        #button-group {
            display: flex;
            align-items: center;
        }

        #button-group button {
            margin: 0 5px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: transparent;
            color: navy;
        }

        #btn-edit-dims {
            margin: 0 10px;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            /* border: 1px solid rgba(0, 0, 128, 0.4); */
            border: 0;
            box-shadow: 0 1px 4px 0 rgba(31, 38, 135, 0.2);
            border-radius: 5px;
            background-color: transparent;
            color: navy;
        }

        #button-group .large-button {
            font-size: 24px;
            width: 50px;
            height: 50px;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 1px 4px 0 rgba(31, 38, 135, 0.2);
        }


        #button-group .small-button {
            font-size: 18px;
            padding: 8px 16px;
            width: 50px;
            height: 40px;
        }

        #button-group button:hover,
        #btn-edit-dims:hover {
            background-color: #e0f1f2;
        }

        #button-group button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #eee;
        }


        /* TODO RM */
        #animation-controls {
            display: none;
        }
    </style>
    <!-- for LaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
    <!-- for anim -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
</head>

<body>
    <!--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        HTML
     -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-->
    <div id="main-container">
        <div id="svg-container">
            <svg id="network" width="1200" height="700"></svg>
        </div>
        <div id="right-container">
            <div id="info-container">
                <div id="info"></div>
                <div id="button-group-container">
                    <div id="button-group">
                        <button id="btn-reset-mlp" class="small-button">↺</button>
                        <button id="btn-shock-weights" class="small-button">ϟ</button>
                        <button id="btn-play-pause" class="large-button">
                            <span id="btn-play-pause-content">▶</span>
                        </button>

                        <button id="btn-step" class="small-button">▶|</button>
                        <button id="btn-fwd-backprop-update" class="small-button">→</button>
                    </div>
                </div>
            </div>
            <div id="controls-container">
                <div id="controls">
                    <span>[2, </span>
                    <input type="text" id="layerDimInput">
                    <span> 3]</span>
                    <button id="btn-edit-dims" onclick="updateNetwork()">Edit hidden layer dimensions</button>
                </div>
                <div id="animation-controls">
                    <h4>note: all explanations in the info box are WIP</h4>
                    <h4>test animations (done?)</h4>
                    <button id="btn-shock-weights">Test Shock Weights</button>
                    <h4>test animations (WIP)</h4>
                    <button id="btn-forward-pass">Test Forward Pass</button>
                    <button id="btn-backward-pass">Test Backward Pass</button>
                    <h4>todo animations</h4>
                    <button id="btn-concurrent-play">Test Step</button>
                    <button id="btn-concurrent-play">Test Optimize (free)</button>
                    <button id="btn-time-locked-play">Test Optimize (time synced)</button>
                </div>
            </div>

        </div>
    </div>
    <div id="reporting-container">
        <div id="epoch-display">Epoch: 0</div>
        <div id="train-loss-display">Train Loss: N/A</div>
        <div id="val-loss-display">Validation Loss: N/A</div>
        <div id="log-container"></div>
    </div>



    <!--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        Javascript
     -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-->
    <script>
        // globals
        let mlp;
        let layerDims;
        let train_split, val_split, test_split;

        let isRunningOptimization = false;
        // let isReadyBackprop = false;
        let optimizationStateName = 'forward';
        let epoch = 0;

        // AdamW
        let learning_rate = 1e-1;
        let beta1 = 0.9;
        let beta2 = 0.95;
        let weight_decay = 1e-4;
        const eps = 1e-8;

        const shockNoiseScale = 0.3; // Adjust this value to control the magnitude of the shock

        const btnPlayPause = document.getElementById('btn-play-pause');
        const btnStep = document.getElementById('btn-step');
        // const btnPlayPauseContent = document.getElementById('btn-play-pause-content');
        const btnResetMLP = document.getElementById('btn-reset-mlp');
        const btnFwdBackUp = document.getElementById('btn-fwd-backprop-update');

        const infoElement = document.getElementById('info');


        let selectedElement = null;
        const svg = document.getElementById('network');
        // const info = document.getElementById('info');
        const initialHidden = "16,"
        const initialLayers = `[2, ${initialHidden} 3]`
        // const initialLayers = "[2, 10, 10, 3]"
        layerDims = JSON.parse(initialLayers)
        const svgWidth = 1200;
        const svgHeight = 700;
        const LATEX_FONT_SIZE = 16;
        const LATEX_COLOR = '#999';
        const LATEX_COLOR_LOSS = '#666';
        const layerColors = {
            x: {
                shape: "#ccc",
                overlay: "rgba(204, 204, 204, 0.1)"
            },
            fc: {
                // keep layer display minimaly white for now
                shape: '#FFFFFF',
                overlay: "rgba(255, 255, 255, 0.2)"
            },
            y: {
                shape: "#ccc",
                overlay: "rgba(204, 204, 204, 0.1)"
            },
            bias: {
                shape: "#999",
            }
        };



        function getLayerColor(layerIndex) {
            if (layerIndex === 0) return layerColors.x;
            if (layerIndex === layerDims.length) return layerColors.y;
            return layerColors.fc;
        }

        function resetAdamMLP() {
            for (const p of mlp.parameters()) {
                p.m = 0.0;
                p.v = 0.0;
            }
        }

        function resetData() {
            [train_split, val_split, test_split] = gen_data(random, 100);

            resetTrainingDisplay();
            epoch = 0;
        }

        function resetMLP() {
            const inputSize = layerDims[0];
            const outputSize = layerDims[layerDims.length - 1];
            const hiddenLayers = layerDims.slice(1, -1);
            mlp = new MLP(inputSize, hiddenLayers.concat(outputSize));
            resetAdamMLP();

            currentTrainingStage = 0;
            epoch = 0;
            resetTrainingDisplay();
            updateButtonState(btnFwdBackUp, currentTrainingStage);
        }


        function updateNetwork() {
            let input = document.getElementById('layerDimInput').value.trim();
            try {
                // Add trailing comma if missing
                if (!input.endsWith(',')) {
                    input += ',';
                }
                const cleanedInput = input.replace(/,\s*$/, ',').trim(); // Ensure single trailing comma
                const newLayers = JSON.parse(`[2, ${cleanedInput} 3]`);
                if (Array.isArray(newLayers) && newLayers.length >= 3 && newLayers.length <= 10 && newLayers.every(n => n <= 16)) {
                    layerDims = newLayers;
                    resetMLP();
                    // Update the input field to reflect the correct interpretation
                    document.getElementById('layerDimInput').value = cleanedInput;
                } else {
                    alert('Invalid input. Please use format n1, n2, .. with max 8 hidden layers and max 16 nodes per layer.');
                }
            } catch (e) {
                alert('Invalid input. Please use format n1, n2, ..');
            }
        }



        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Draw the MLP
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function drawNetwork() {
            // n_layers = 
            // algo: start with nin. create
            svg.innerHTML = '';

            if (!mlp) {
                resetMLP();
            }

            const layerGap = svgWidth / (layers.length + 2);
        }


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Draw nodes
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // function drawNode(x, y, layerIndex, nodeIndex, parent, isBiasNode = false) {


        // function drawBiasNode(x, y, layerIndex, parent) {

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Draw connections
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // function drawConnections(layerIndex, x, layerGap) {


        // function drawYConnections(layerIndex, x, layerGap) {


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Display detailed info top-right
        // TODO later - selectedElement logic
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        function showInfo(event) {
            const target = event.target;
            let content = '';

            if (target.id === 'btn-play-pause' || target.id === "btn-play-pause-content") {
                if (isRunningOptimization) {
                    content = "Pause optimization";
                } else {
                    content = "Run optimization";
                }
            } else if (target.id === 'btn-fwd-backprop-update') {
                switch (optimizationStateName) {
                    case 'forward':
                        content = "**Forward pass**: run inference/prediction on the input data to produce predictions $$\\hat{y}$$ and calculate loss with respect to the true output values $$y$$.";
                        break;
                    case 'backprop':
                        // content = "**Backpropagate gradients**: Use the loss information to calculate gradients for each of the tunable weight parameters $$ W $$, starting at the end of the MLP and using the gradient information from later layers to calculate how much we should change the weights in the earlier layers. We are able to accomplish this using the chain rule from calculus ($$\\dfrac{dL}{dW_{l}} → \\dfrac{dL}{dW_{l-1}} → ... → \\dfrac{dL}{dW_{1}}$$, where $$l$$ is the number of layers in our MLP)";
                        content = "**Backpropagate gradients**: Use the loss information to calculate gradients for each of the tunable weight parameters $$ W $$, starting at the end of the MLP and using the gradient information from later layers to calculate how much we should change the weights in the earlier layers. We are able to accomplish this using the chain rule from calculus.";
                        break;
                    case 'update':
                        content = "**Update weights**: Use the gradient information to update the weights $$ W $$ of the network based on our optimization algorithm (AdamW in this case) and hyperparameters (e.g. learning rate, weight decay), with the goal of nudging this network towards better predictions of the output given the input. We also zeros out the gradients to prepare for the next step.";
                        break;
                }
            } else if (target.id === 'btn-reset-mlp') {
                content = "Reset the network parameters to randomly initialized values based on the Uniform Xavier initialization.";
            } else if (target.id === 'btn-shock-weights') {
                content = `\"Shock\" the weights: perturb the weight parameters by adding a small amount of random uniform noise between $$[-${shockNoiseScale}, ${shockNoiseScale}]$$.`;
            } else if (target.id === 'btn-step') {
                content = "Run one full epoch of the training loop and show network animations illustrating the forward pass, backpropagation of gradients, and update of the weights.";
            }
            renderInfoContent(infoElement, content);
        }


        function clearInfo(event) {
            if (!selectedElement) {
                document.getElementById('info').textContent = '';
            }
        }



        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Create figure labels
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function createLatexLabel(x, y, text, color) {
            const foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
            foreignObject.setAttribute('x', x - 75);
            foreignObject.setAttribute('y', y - 20);
            foreignObject.setAttribute('width', '150');
            foreignObject.setAttribute('height', '40');
            foreignObject.classList.add('latex-label');
            foreignObject.dataset.latex = text;

            const div = document.createElement('div');
            div.style.fontSize = LATEX_FONT_SIZE + 'px';
            div.style.color = color;
            div.style.display = 'flex';
            div.style.justifyContent = 'center';
            div.style.alignItems = 'center';
            div.style.height = '100%';

            katex.render(text, div, {
                throwOnError: false
            });

            foreignObject.appendChild(div);
            foreignObject.addEventListener('mouseover', showInfo);
            foreignObject.addEventListener('mouseout', clearInfo);
            foreignObject.addEventListener('click', showInfo);

            return foreignObject;
        }


        // function addLayerLabels() {


        function addLossLabel() {
            const lastLayerX = (layers.length + 1) * (svgWidth / (layers.length + 2));
            const braceWidth = 15;
            svg.appendChild(createLatexLabel(lastLayerX + braceWidth * 1.5 + 80, svgHeight / 2, 'L(\\hat{\\mathbf{y}}, \\mathbf{y})', LATEX_COLOR_LOSS));
        }


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Rendering events and helpers
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function renderInfoContent(element, content) {
            element.innerHTML = '';
            let currentIndex = 0;

            while (currentIndex < content.length) {
                if (content.startsWith('$$', currentIndex)) {
                    // LaTeX content
                    const endIndex = content.indexOf('$$', currentIndex + 2);
                    if (endIndex === -1) {
                        console.error('Unclosed LaTeX at position', currentIndex);
                        break;
                    }
                    const latexContent = content.slice(currentIndex + 2, endIndex);
                    const span = document.createElement('span');
                    katex.render(latexContent, span, {
                        throwOnError: false,
                        displayMode: false
                    });
                    element.appendChild(span);
                    currentIndex = endIndex + 2;
                } else if (content.startsWith('**', currentIndex)) {
                    // Bold content
                    const endIndex = content.indexOf('**', currentIndex + 2);
                    if (endIndex === -1) {
                        console.error('Unclosed bold at position', currentIndex);
                        break;
                    }
                    const boldContent = content.slice(currentIndex + 2, endIndex);
                    const strong = document.createElement('strong');
                    strong.textContent = boldContent;
                    element.appendChild(strong);
                    currentIndex = endIndex + 2;
                } else {
                    // Plain text
                    const nextSpecialChar = Math.min(
                        content.indexOf('$$', currentIndex) === -1 ? Infinity : content.indexOf('$$', currentIndex),
                        content.indexOf('**', currentIndex) === -1 ? Infinity : content.indexOf('**', currentIndex)
                    );
                    const textContent = content.slice(currentIndex, nextSpecialChar === Infinity ? undefined : nextSpecialChar);
                    const lines = textContent.split('\n');
                    lines.forEach((line, index) => {
                        element.appendChild(document.createTextNode(line));
                        if (index < lines.length - 1) {
                            element.appendChild(document.createElement('br'));
                        }
                    });
                    currentIndex = nextSpecialChar === Infinity ? content.length : nextSpecialChar;
                }
            }
        }



        function handleNodeHover(event) {
            const target = event.target;
            if (target.classList.contains('node')) {
                const layerIndex = parseInt(target.dataset.layer);
                const nodeIndex = parseInt(target.dataset.node);

                function highlightConnection(conn) {
                    conn.classList.add('highlighted');
                    conn.setAttribute('stroke-width', '3');

                    const strength = parseFloat(conn.dataset.strength);
                    const gradient = parseFloat(conn.dataset.gradient);
                    const absGradient = Math.abs(gradient);
                    const maxGradient = 1; // Adjust this value based on your gradient range

                    let color;
                    if (gradient >= 0) {
                        color = `rgba(0, 0, 255, ${absGradient / maxGradient})`;
                    } else {
                        color = `rgba(255, 0, 0, ${absGradient / maxGradient})`;
                    }

                    // conn.style.filter = `drop-shadow(0 0 3px ${color})`;
                    if (strength >= 0) {
                        conn.classList.add('positive');
                        conn.classList.remove('negative');
                    } else {
                        conn.classList.add('negative');
                        conn.classList.remove('positive');
                    }
                }

                // Highlight incoming connections
                if (layerIndex > 0) {
                    const incomingConnections = document.querySelectorAll(`.connection[data-to="${layerIndex},${nodeIndex}"]`);
                    incomingConnections.forEach(highlightConnection);
                }

                // Highlight outgoing connections
                if (layerIndex < layers.length - 1) {
                    const outgoingConnections = document.querySelectorAll(`.connection[data-from="${layerIndex},${nodeIndex}"]`);
                    outgoingConnections.forEach(highlightConnection);
                }
            }
        }


        function resetNodeHover() {
            // if (selectedElement) return; // Don't reset if there's a selected element
            const highlightedConnections = document.querySelectorAll('.connection.highlighted');
            highlightedConnections.forEach(conn => {
                conn.classList.remove('highlighted', 'positive', 'negative');
                conn.setAttribute('stroke-width', '1');
                conn.style.filter = '';
            });
        }


        function resetConnectionAppearance(event) {
            const target = event.target;

            if (target.classList.contains('connection')) {
                target.style.filter = '';
                target.classList.remove('highlighted', 'positive', 'negative');
            }
        }


        function updateConnectionOpacity() {
            const connections = document.querySelectorAll('.connection');
            connections.forEach(connection => {
                if (showConnectionStrengthOpacity) {
                    const strength = parseFloat(connection.dataset.strength);
                    const maxStrength = parseFloat(connection.dataset.maxStrength);
                    const opacity = strength / maxStrength;
                    connection.setAttribute('stroke-opacity', opacity);
                } else {
                    connection.setAttribute('stroke-opacity', 1);
                }
            });
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Animations
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        // after micrograd implemented: nodes act as accumulators and change color and intensity based
        // on weighted input and activation function
        function animateForwardPass() { }

        function animateBackwardPass() { }

        function animateUpdateWeights() { }

        function animateShockWeights() { }


        function resetTrainingDisplay() {
            document.getElementById('epoch-display').textContent = `Epoch: 0`;
            document.getElementById('train-loss-display').textContent = `Train Loss: N/A`;
            document.getElementById('val-loss-display').textContent = `Validation Loss: N/A`;
        }

        function updateTrainingDisplay(epochVal, trainLoss, valLoss) {
            document.getElementById('epoch-display').textContent = `Epoch: ${epochVal}`;
            if (trainLoss !== null) {
                document.getElementById('train-loss-display').textContent = `Train Loss: ${trainLoss.toFixed(20)}`;
            }
            if (valLoss !== null) {
                document.getElementById('val-loss-display').textContent = `Validation Loss: ${valLoss.toFixed(20)}`;
            }
        }

        function logMessage(message) {
            const logContainer = document.getElementById('log-container');
            logContainer.innerHTML += `<p>${message}</p>`;
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Micrograd MLP
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        let currentTrainingStage = 0; // 0: forward, 1: backward, 2: update


        function trainModelStep(stage, fullStep = false) {
            if (!mlp) {
                console.error("MLP not initialized");
                return;
            }

            if (fullStep) {
                // in case we are partway through a cycle, reset stage and grad
                currentTrainingStage = 0;
                mlp.zeroGrad();
                updateButtonState(btnFwdBackUp, currentTrainingStage);


                // evaluate the validation split every few steps
                if (epoch % 10 === 0) {
                    const val_loss = evalSplit(mlp, val_split);
                    updateTrainingDisplay(epoch, null, val_loss);
                }

                // forward the network (get logits of all training datapoints)
                let loss = new Value(0);
                for (const [x, y] of train_split) {
                    const logits = mlp.call([new Value(x[0]), new Value(x[1])]);
                    loss = loss.add(crossEntropy(logits, y));
                }
                loss = loss.mul(1.0 / train_split.length); // normalize the loss

                // backward pass (deposit the gradients)
                loss.backward();

                // update with AdamW
                for (const p of mlp.parameters()) {
                    p.m = beta1 * p.m + (1 - beta1) * p.grad;
                    p.v = beta2 * p.v + (1 - beta2) * Math.pow(p.grad, 2);
                    const m_hat = p.m / (1 - Math.pow(beta1, epoch + 1));
                    const v_hat = p.v / (1 - Math.pow(beta2, epoch + 1));
                    p.data -= learning_rate * (m_hat / (Math.sqrt(v_hat) + eps) + weight_decay * p.data);
                }
                mlp.zeroGrad();
                updateTrainingDisplay(epoch, loss.data, null);

                epoch++;
            } else {
                switch (stage) {
                    case 0: // Forward pass
                        if (epoch % 10 === 0) {
                            const val_loss = evalSplit(mlp, val_split);
                            updateTrainingDisplay(epoch, null, val_loss);
                        }

                        loss = new Value(0);
                        for (const [x, y] of train_split) {
                            const logits = mlp.call([new Value(x[0]), new Value(x[1])]);
                            loss = loss.add(crossEntropy(logits, y));
                        }
                        loss = loss.mul(1.0 / train_split.length);
                        updateTrainingDisplay(epoch, loss.data, null);
                        break;

                    case 1: // Backward pass
                        if (loss) {
                            loss.backward();
                        } else {
                            console.error("No loss computed. Run forward pass first.");
                        }
                        break;

                    case 2: // Update
                        for (const p of mlp.parameters()) {
                            p.m = beta1 * p.m + (1 - beta1) * p.grad;
                            p.v = beta2 * p.v + (1 - beta2) * Math.pow(p.grad, 2);
                            const m_hat = p.m / (1 - Math.pow(beta1, epoch + 1));
                            const v_hat = p.v / (1 - Math.pow(beta2, epoch + 1));
                            p.data -= learning_rate * (m_hat / (Math.sqrt(v_hat) + eps) + weight_decay * p.data);
                        }
                        mlp.zeroGrad();
                        epoch++;
                        break;
                }
                currentTrainingStage = (stage + 1) % 3;
                updateButtonState(btnFwdBackUp, currentTrainingStage);
            }
        }


        function trainModel(state) {
            function trainingLoop() {
                if (!isRunningOptimization) return;

                trainModelStep(state, true);

                if (currentTrainingStage === 0) {
                    // We've completed a full cycle, request the next frame
                    requestAnimationFrame(trainingLoop);
                } else {
                    // We're in the middle of a cycle, continue immediately
                    trainingLoop();
                }
            }
            trainingLoop();
        }

        class RNG {
            constructor(seed) {
                this.state = BigInt(seed);
            }

            random_u32() {
                // xorshift rng: https://en.wikipedia.org/wiki/Xorshift#xorshift.2A
                this.state = BigInt.asUintN(64, this.state);
                this.state ^= (this.state >> 12n) & 0xFFFFFFFFFFFFFFFFn;
                this.state ^= (this.state << 25n) & 0xFFFFFFFFFFFFFFFFn;
                this.state ^= (this.state >> 27n) & 0xFFFFFFFFFFFFFFFFn;

                return Number((this.state * 0x2545F4914F6CDD1Dn >> 32n) & 0xFFFFFFFFn);
            }

            random() {
                // random Number in [0, 1)
                return (this.random_u32() >>> 8) / 16777216.0;
            }

            uniform(a = 0.0, b = 1.0) {
                // random Number in [a, b)
                return a + (b - a) * this.random();
            }
        }

        function gen_data(random, n = 100) {
            let pts = [];
            for (let i = 0; i < n; i++) {
                let x = random.uniform(-2.0, 2.0);
                let y = random.uniform(-2.0, 2.0);
                // concentric circles
                // label = 0 if x**2 + y**2 < 1 else 1 if x**2 + y**2 < 2 else 2
                // very simple dataset
                let label = x < 0 ? 0 : y < 0 ? 1 : 2;
                pts.push([[x, y], label]);
            }
            // create train/val/test splits of the data (80%, 10%, 10%)
            let tr = pts.slice(0, Math.floor(0.8 * n));
            let val = pts.slice(Math.floor(0.8 * n), Math.floor(0.9 * n));
            let te = pts.slice(Math.floor(0.9 * n));
            return [tr, val, te];
        }

        const random = new RNG(42);

        class Value {
            // stores a single scalar value and its gradient
            constructor(data, _children = [], _op = '') {
                this.data = data;
                this.grad = 0;
                this._backward = () => { };
                this._prev = new Set(_children);
                this._op = _op;
            }

            add(other) {
                other = other instanceof Value ? other : new Value(other);
                const out = new Value(this.data + other.data, [this, other], '+');
                out._backward = () => {
                    this.grad += out.grad;
                    other.grad += out.grad;
                };

                return out;
            }

            mul(other) {
                other = other instanceof Value ? other : new Value(other);
                const out = new Value(this.data * other.data, [this, other], '*');
                out._backward = () => {
                    this.grad += other.data * out.grad;
                    other.grad += this.data * out.grad;
                };

                return out;
            }

            pow(other) {
                if (typeof other !== 'number') throw new Error("only supporting number powers for now");
                const out = new Value(Math.pow(this.data, other), [this], `**${other}`);

                out._backward = () => {
                    this.grad += other * Math.pow(this.data, other - 1) * out.grad;
                };

                return out;
            }

            relu() {
                const out = new Value(this.data < 0 ? 0 : this.data, [this], 'ReLU');
                out._backward = () => {
                    this.grad += (out.data > 0) * out.grad;
                };

                return out;
            }

            tanh() {
                const x = Math.tanh(this.data);
                const out = new Value(x, [this], 'tanh');
                out._backward = () => {
                    this.grad += (1 - x * x) * out.grad;
                };

                return out;
            }

            exp() {
                const x = Math.exp(this.data);
                const out = new Value(x, [this], 'exp');
                out._backward = () => {
                    this.grad += x * out.grad;
                };

                return out;
            }

            log() {
                const out = new Value(Math.log(this.data), [this], 'log');
                out._backward = () => {
                    this.grad += (1 / this.data) * out.grad;
                };

                return out;
            }

            backward() {
                const topo = [];
                const visited = new Set();

                function buildTopo(v) {
                    if (!visited.has(v)) {
                        visited.add(v);
                        for (const child of v._prev) {
                            buildTopo(child);
                        }
                        topo.push(v);
                    }
                }

                buildTopo(this);

                this.grad = 1;
                for (const v of topo.reverse()) {
                    v._backward();
                }
            }

            neg() { return this.mul(-1); }
            sub(other) { return this.add(other instanceof Value ? other.neg() : new Value(-other)); }
            div(other) { return this.mul(other instanceof Value ? other.pow(-1) : new Value(Math.pow(other, -1))); }

            toString() {
                return `Value(data=${this.data}, grad=${this.grad})`;
            }
        }


        class Module {
            zeroGrad() {
                for (const p of this.parameters()) {
                    p.grad = 0;
                }
            }

            parameters() {
                return [];
            }
        }

        class Neuron extends Module {
            constructor(nin, kwargs) {
                super();
                this.w = Array(nin).fill().map(() => new Value(random.uniform(-1, 1) * Math.pow(nin, -0.5)));
                this.b = new Value(0);
                this.nonlin = kwargs.nonlin !== undefined ? kwargs.nonlin : true;
            }

            call(x) {
                const act = this.w.reduce((sum, wi, i) => sum.add(wi.mul(x[i])), this.b);
                return this.nonlin ? act.tanh() : act;
            }

            parameters() {
                return [...this.w, this.b];
            }

            toString() {
                return `${this.nonlin ? 'TanH' : 'Linear'}Neuron(${this.w.length})`;
            }
        }

        class Layer extends Module {
            constructor(nin, nout, kwargs = {}) {
                super();
                this.neurons = Array(nout).fill().map(() => new Neuron(nin, kwargs));
            }

            call(x) {
                const out = this.neurons.map(n => n.call(x));
                return out.length === 1 ? out[0] : out;
            }

            parameters() {
                return this.neurons.flatMap(n => n.parameters());
            }

            toString() {
                return `Layer of [${this.neurons.join(', ')}]`;
            }
        }

        class MLP extends Module {
            constructor(nin, nouts) {
                super();
                const sz = [nin, ...nouts];
                this.layers = sz.slice(0, -1).map((s, i) => new Layer(s, sz[i + 1], { nonlin: i !== nouts.length - 1 }));

            }

            call(x) {
                for (const layer of this.layers) {
                    x = layer.call(x);
                    x = Array.isArray(x) ? x : [x]
                }
                return x
            }

            parameters() {
                return this.layers.flatMap(l => l.parameters());
            }

            toString() {
                return `MLP of [${this.layers.join(', ')}]`;
            }

            shockWeights() {
                for (const layer of this.layers) {
                    for (const neuron of layer.neurons) {
                        for (const w of neuron.w) {
                            const noise = random.uniform(-shockNoiseScale, shockNoiseScale);
                            w.data += noise;
                        }
                        const bias_noise = random.uniform(-shockNoiseScale, shockNoiseScale);
                        neuron.b.data += bias_noise;
                    }
                }
            }
        }

        function crossEntropy(logits, target) {
            // subtract the max for numerical stability (avoids overflow)
            const maxVal = Math.max(...logits.map(v => v.data));
            const shiftedLogits = logits.map(v => v.sub(maxVal));
            // 1) evaluate elementwise e^x
            const ex = shiftedLogits.map(x => x.exp());
            // 2) compute the sum of the above
            const denom = ex.reduce((sum, x) => sum.add(x));
            // 3) normalize by the sum to get probabilities
            const probs = ex.map(x => x.div(denom));
            // 4) log the probabilities at target
            const logp = probs[target].log();
            // 5) the negative log likelihood loss (invert so we get a loss - lower is better)
            const nll = logp.neg();
            return nll;
        }

        // evaluation utility to compute the loss on a given split of the dataset
        function evalSplit(model, split) {
            // evaluate the loss of a split
            let loss = new Value(0);
            for (const [x, y] of split) {
                const logits = model.call([new Value(x[0]), new Value(x[1])]);
                loss = loss.add(crossEntropy(logits, y));
            }
            loss = loss.mul(1.0 / split.length); // normalize the loss
            return loss.data;
        }

        function updateButtonState(button, stage) {
            switch (stage) {
                case 0:
                    button.textContent = '→';
                    optimizationStateName = 'forward';
                    break;
                case 1:
                    button.textContent = '←';
                    optimizationStateName = 'backprop';
                    break;
                case 2:
                    button.textContent = '↑';
                    optimizationStateName = 'update';
                    break;
            }
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Add event listeners and draw
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        svg.addEventListener('click', function (event) {
            showInfo(event);
        });

        function addEventListeners(element) {
            element.addEventListener('mouseover', showInfo);
            element.addEventListener('mouseout', clearInfo);
            element.addEventListener('click', showInfo);
        }

        document.querySelectorAll('.node, .connection, .layer, .latex-label').forEach(addEventListeners);

        btnPlayPause.addEventListener('click', function (event) {
            isRunningOptimization = !isRunningOptimization;
            this.querySelector('span').textContent = isRunningOptimization ? '⏸' : '▶';

            if (isRunningOptimization) {
                trainModel(currentTrainingStage);
            }

            const buttonsDisableRunning = ['btn-reset-mlp', 'btn-shock-weights', 'btn-step', 'btn-fwd-backprop-update'];
            buttonsDisableRunning.forEach(id => {
                const button = document.getElementById(id);
                button.disabled = isRunningOptimization;
            });
            showInfo(event);
        });

        btnStep.addEventListener('click', function () {
            trainModelStep(currentTrainingStage, true);
            updateButtonState(btnFwdBackUp, currentTrainingStage);
            showInfo({ target: this });
        });

        btnFwdBackUp.addEventListener('click', function () {
            trainModelStep(currentTrainingStage, false);
            updateButtonState(this, currentTrainingStage);
            showInfo({ target: this });
        });

        document.getElementById('btn-shock-weights').addEventListener('click', function () {
            mlp.shockWeights();
        });

        // Add mouseover and mouseout event listeners for the new buttons
        ['btn-reset-mlp', 'btn-shock-weights', 'btn-step', 'btn-fwd-backprop-update', 'btn-play-pause'].forEach(id => {
            const button = document.getElementById(id);
            button.addEventListener('mouseover', showInfo);
            button.addEventListener('mouseout', clearInfo);
        });

        // drawNetwork();
        window.onload = function () {
            document.getElementById('layerDimInput').value = initialHidden;
            resetData();
            resetMLP();
        };

    </script>
</body>

</html>