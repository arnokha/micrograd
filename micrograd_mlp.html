<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Micrograd MLP Viz 2</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }

        #reporting-container {
            font-size: 16px;
            line-height: 1.5;
            font-family: 'Courier New', Courier, monospace;
            padding: 20px;
        }

        .loss-display {
            display: flex;
        }

        .loss-label {
            width: 250px;
            /* Adjust this value as needed */
        }

        #main-container {
            display: flex;
            width: 100%;
            height: 700px;
        }

        #svg-container {
            flex: 0 0 1200px;
            z-index: 10;
            /* overflow: auto; */
        }

        #right-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        #info-container {
            /* flex: 1; */
            min-height: 350px;
            padding: 15px;
            overflow-y: auto;
        }

        .container {
            display: flex;
            justify-content: center;
        }

        #controls {
            padding: 0 20px;
        }

        #bottom-right-container {
            flex: 1;
            padding: 15px 20px;
            overflow-y: visible;
        }

        #info {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 16px;
            line-height: 1.5;

            height: 250px;
            border-radius: 15px;
            overflow-y: auto;

        }

        #info .katex {
            font-size: 1.2em;
        }

        /*-=-=-=-=-=-=-=-=-=-=-=-=*/
        /* MLP CSS*/
        /*-=-=-=-=-=-=-=-=-=-=-=-=*/
        #network {
            border: 1px solid #ccc;
        }

        #layerDimInput {
            width: 75px;
            font-size: 16px;
            font-weight: 500;
            border: 0;
            background-color: #dbf4ff33;
        }

        #layerDimInput:hover {
            outline: 1px solid navy;
        }

        .layer:hover rect {
            fill: rgb(190, 190, 190);
            fill-opacity: 0.1;
        }

        .latex-label:hover {
            filter: brightness(0.5);
        }

        .latex-label.selected {
            filter: brightness(0.5);
        }

        .layer.selected>rect {
            fill: rgb(190, 190, 190);
            fill-opacity: 0.3;
        }

        /* Connections */
        .connection:hover {
            stroke-width: 3;
            filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.7));
        }

        .connection.positive {
            stroke: rgb(100, 100, 255);
        }

        .connection.negative {
            stroke: rgb(255, 100, 100);
        }

        .connection.selected {
            stroke-width: 3;
            stroke-opacity: 1;
        }

        /* Nodes */
        .node {
            cursor: pointer;
        }

        .node:hover {
            fill: #ffb650;
        }

        .node.selected {
            fill: #ffb650;
        }

        /* MLP actions */
        #button-group-container {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }

        #button-group {
            display: flex;
            align-items: center;
        }

        #button-group button {
            margin: 0 5px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: transparent;
            color: navy;
        }

        #btn-edit-dims {
            margin: 0 10px;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            /* border: 1px solid rgba(0, 0, 128, 0.4); */
            border: 0;
            box-shadow: 0 1px 4px 0 rgba(31, 38, 135, 0.2);
            border-radius: 5px;
            background-color: transparent;
            color: navy;
        }

        #button-group .large-button {
            font-size: 24px;
            width: 50px;
            height: 50px;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 1px 4px 0 rgba(31, 38, 135, 0.2);
        }


        #button-group .small-button {
            font-size: 18px;
            padding: 8px 16px;
            width: 50px;
            height: 40px;
        }

        #button-group button:hover,
        #btn-edit-dims:hover {
            background-color: #e0f1f2;
        }

        #button-group button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #eee;
        }

        /* Data plot */
        #data-visualization {
            margin-top: 30px;
        }

        #data-plot {
            border: 1px solid #ccc;
        }

        .data-point {
            stroke-width: 2;
            fill: none;
        }

        .data-point.hit {
            fill-opacity: 0.3;
        }

        /* .data-point.train {} */

        .data-point.val {
            stroke: #999;
            stroke-width: 2;
        }

        .data-point.miss {
            fill-opacity: 1;
        }

        .label-missing {
            fill: gray;
            fill-opacity: 1;
        }

        .label-0 {
            fill: navy;
        }

        .label-1 {
            fill: gold;
        }

        .label-2 {
            fill: red;
        }


        /* TODO RM */
        #animation-controls {
            display: none;
        }
    </style>
    <!-- for LaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
    <!-- for anim -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
</head>

<body>
    <!--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        HTML
     -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-->
    <div id="main-container">
        <div id="svg-container">
            <svg id="network" width="1200" height="700"></svg>
        </div>
        <div id="right-container">
            <div id="info-container">
                <div id="info"></div>
                <div id="button-group-container">
                    <div id="button-group">
                        <button id="btn-reset-mlp" class="small-button">↺</button>
                        <button id="btn-shock-weights" class="small-button">ϟ</button>
                        <button id="btn-play-pause" class="large-button">
                            <span id="btn-play-pause-content">▶</span>
                        </button>

                        <button id="btn-step" class="small-button">▶|</button>
                        <button id="btn-fwd-backprop-update" class="small-button">→</button>
                    </div>
                </div>
            </div>
            <div id="bottom-right-container">
                <div id="controls">
                    <span>[2, </span>
                    <input type="text" id="layerDimInput">
                    <span> 3]</span>
                    <button id="btn-edit-dims" onclick="updateNetwork()">Edit hidden layer dimensions</button>
                </div>
                <div class="container">
                    <div id="data-visualization">
                        <svg id="data-plot" width="380" height="380"></svg>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="reporting-container">
        <div id="epoch-display">Epoch: 0</div>
        <div id="train-loss-display" class="loss-display">
            <span class="loss-label">Train Loss:</span>
            <span id="train-loss-value">N/A</span>
        </div>
        <div id="val-loss-display" class="loss-display">
            <span class="loss-label">Validation Loss:</span>
            <span id="val-loss-value">N/A</span>
        </div>
        <div id="log-container"></div>
    </div>




    <!--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        Javascript
     -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-->
    <script>
        // globals
        let mlp;
        let layerDims;
        let train_split, val_split, test_split;
        let predsTrain, predsVal;

        let isRunningOptimization = false;
        // let isReadyBackprop = false;
        let optimizationStateName = 'forward';
        let epoch = 0;

        let currentTrainingStage = 0; // 0: forward, 1: backward, 2: update

        // AdamW
        let learning_rate = 1e-1;
        let beta1 = 0.9;
        let beta2 = 0.95;
        let weight_decay = 1e-4;
        const eps = 1e-8;

        const shockNoiseScale = 0.5; // Adjust this value to control the magnitude of the shock

        const btnPlayPause = document.getElementById('btn-play-pause');
        const btnStep = document.getElementById('btn-step');
        // const btnPlayPauseContent = document.getElementById('btn-play-pause-content');
        const btnResetMLP = document.getElementById('btn-reset-mlp');
        const btnFwdBackUp = document.getElementById('btn-fwd-backprop-update');

        const infoElement = document.getElementById('info');


        let selectedElement = null;
        const svg = document.getElementById('network');
        // const info = document.getElementById('info');
        const initialHidden = "16,"
        const initialLayers = `[2, ${initialHidden} 3]`
        // const initialLayers = "[2, 10, 10, 3]"
        layerDims = JSON.parse(initialLayers)
        let svgWidth, svgHeight;


        const LATEX_FONT_SIZE = 16;
        const LATEX_COLOR = '#999';
        const LATEX_COLOR_LOSS = '#666';
        const layerColors = {
            x: {
                shape: "#ccc",
                overlay: "rgba(204, 204, 204, 0.1)"
            },
            fc: {
                // keep layer display minimaly white for now
                shape: '#FFFFFF',
                overlay: "rgba(255, 255, 255, 0.2)"
            },
            y: {
                shape: "#ccc",
                overlay: "rgba(204, 204, 204, 0.1)"
            },
            bias: {
                shape: "#999",
            }
        };



        function getLayerColor(layerIndex) {
            if (layerIndex === 0) return layerColors.x;
            if (layerIndex === layerDims.length) return layerColors.y;
            return layerColors.fc;
        }

        function resetAdamMLP() {
            for (const p of mlp.parameters()) {
                p.m = 0.0;
                p.v = 0.0;
            }
        }

        function resetData() {
            [train_split, val_split, test_split] = gen_data(random, 100);
            resetTrainingDisplay();
            epoch = 0;
            predsTrain = [];
            predsVal = [];
            updateDataPlot();
        }


        function resetMLP() {
            const inputSize = layerDims[0];
            const outputSize = layerDims[layerDims.length - 1];
            const hiddenLayers = layerDims.slice(1, -1);
            mlp = new MLP(inputSize, hiddenLayers.concat(outputSize));
            resetAdamMLP();

            currentTrainingStage = 0;
            epoch = 0;
            resetTrainingDisplay();
            updateButtonState(btnFwdBackUp, currentTrainingStage);
            predsTrain = [];
            predsVal = [];
            updateDataPlot();
        }


        function updateNetwork() {
            let input = document.getElementById('layerDimInput').value.trim();
            try {
                // Add trailing comma if missing
                if (!input.endsWith(',')) {
                    input += ',';
                }
                const cleanedInput = input.replace(/,\s*$/, ',').trim(); // Ensure single trailing comma
                const newLayers = JSON.parse(`[2, ${cleanedInput} 3]`);
                if (Array.isArray(newLayers) && newLayers.length >= 3 && newLayers.length <= 10 && newLayers.every(n => n <= 16)) {
                    layerDims = newLayers;
                    resetMLP();
                    // Update the input field to reflect the correct interpretation
                    document.getElementById('layerDimInput').value = cleanedInput;
                } else {
                    alert('Invalid input. Please use format n1, n2, .. with max 8 hidden layers and max 16 nodes per layer.');
                }
            } catch (e) {
                alert('Invalid input. Please use format n1, n2, ..');
            }
        }

        function updateSvgDimensions() {
            const dimensions = getSvgDimensions();
            svgWidth = dimensions.width;
            svgHeight = dimensions.height;
        }



        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Draw the MLP
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function drawNetwork() {
            svg.innerHTML = '';

            if (!mlp) {
                resetMLP();
            }

            const layerGap = svgWidth / (layers.length + 2);
        }


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Draw nodes
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // function drawNode(x, y, layerIndex, nodeIndex, parent, isBiasNode = false) {


        // function drawBiasNode(x, y, layerIndex, parent) {

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Draw connections
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // function drawConnections(layerIndex, x, layerGap) {


        // function drawYConnections(layerIndex, x, layerGap) {


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Draw data points
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function drawGrid() {
            const svg = document.getElementById('data-plot');
            const width = parseInt(svg.getAttribute('width'));
            const height = parseInt(svg.getAttribute('height'));

            // Function to create a line element
            function createLine(x1, y1, x2, y2) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1);
                line.setAttribute('y1', y1);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', '#eee');
                line.setAttribute('stroke-width', '1');
                return line;
            }

            // Draw center lines
            svg.appendChild(createLine(0, height / 2, width, height / 2));
            svg.appendChild(createLine(width / 2, 0, width / 2, height));

            // Draw ticks
            for (let i = 1; i <= 3; i++) {
                const x = (width / 4) * i;
                const y = (height / 4) * i;
                svg.appendChild(createLine(x, height / 2 - 5, x, height / 2 + 5));
                svg.appendChild(createLine(width / 2 - 5, y, width / 2 + 5, y));
            }
        }

        function plotDataPoints(svg, dataPoints, predictions, isTrainingSet, dataPointSize = 5) {
            const width = parseInt(svg.getAttribute('width'));
            const height = parseInt(svg.getAttribute('height'));
            const dataMinX = -2;
            const dataMaxX = 2;
            const dataMinY = -2;
            const dataMaxY = 2;
            const scaleX = width / 4;
            const scaleY = height / 4;

            for (let i = 0; i < dataPoints.length; i++) {
                const [x, y] = dataPoints[i];

                const cx = (x[0] - dataMinX) * scaleX;
                const cy = height - (x[1] - dataMinY) * scaleY;

                const label = y;
                let predictedLabel;
                if (predictions && predictions[i] !== undefined) {
                    predictedLabel = predictions[i];
                } else {
                    predictedLabel = "missing";
                }
                const isHit = predictedLabel === y;
                let shape;
                switch (label) {
                    case 0:
                        shape = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        shape.setAttribute('cx', cx);
                        shape.setAttribute('cy', cy);
                        shape.setAttribute('r', dataPointSize);
                        break;
                    case 1:
                        shape = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        shape.setAttribute('x', cx - dataPointSize);
                        shape.setAttribute('y', cy - dataPointSize);
                        shape.setAttribute('width', dataPointSize * 2);
                        shape.setAttribute('height', dataPointSize * 2);
                        break;
                    case 2:
                        shape = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        const adjSz = dataPointSize + 1 // make triangles slightly bigger
                        shape.setAttribute('points', `${cx},${cy - adjSz} ${cx - adjSz},${cy + adjSz} ${cx + adjSz},${cy + adjSz}`);
                        break;
                    default:
                        console.error('Unknown label:', label);
                        continue;
                }

                shape.setAttribute('class', `data-point ${isHit ? 'hit' : 'miss'} label-${predictedLabel} ${isTrainingSet ? 'train' : 'val'}`);

                // Add data attributes for showInfo
                shape.dataset.x0 = x[0].toFixed(2);
                shape.dataset.x1 = x[1].toFixed(2);
                shape.dataset.actualLabel = label;
                shape.dataset.predictedLabel = predictedLabel;
                shape.dataset.isHit = isHit;
                shape.dataset.set = isTrainingSet ? 'Training' : 'Validation';

                // Add event listeners
                shape.addEventListener('mouseover', showDataPointInfo);
                shape.addEventListener('mouseout', clearInfo);

                svg.appendChild(shape);
            }
        }

        function showDataPointInfo(event) {
            const target = event.target;
            const content = `**${target.dataset.set}** Data Point\n
                Coordinates: (${target.dataset.x0}, ${target.dataset.x1})
                Actual Label: ${target.dataset.actualLabel}
                Predicted Label: ${target.dataset.predictedLabel}\n
                ${target.dataset.isHit === 'true' ? '**Correct** Prediction' : '**INCORRECT** Prediction'}
            `;
            renderInfoContent(infoElement, content);
        }

        function showReportingInfo(event) {
            const target = event.currentTarget;
            let content = '';

            function formatLossForLatex(lossValue) {
        if (lossValue === 'N/A') return 'N/A';
        const number = parseFloat(lossValue);
        if (isNaN(number)) return 'N/A';
        
        // Format to scientific notation with 5 decimal places
        let [coefficient, exponent] = number.toExponential(3).split('e');
        
        // Remove leading '+' from exponent if present
        exponent = parseInt(exponent);
        
        // Format for LaTeX
        return `${coefficient} \\times 10^{${exponent}}`;
    }

    if (target.id === 'epoch-display') {
        content = "An **epoch** is one complete pass through the entire training dataset. It represents a full cycle of training where the model has seen and learned from all available training examples once.";
    } else if (target.id === 'train-loss-display') {
        const trainLoss = formatLossForLatex(document.getElementById('train-loss-value').textContent);
        content = `**Train Loss**: The average loss (error) of the model on the training dataset.\n\nLower values indicate better performance on the training data.\n\nCurrent value: $$ ${trainLoss}$$`;
    } else if (target.id === 'val-loss-display') {
        const valLoss = formatLossForLatex(document.getElementById('val-loss-value').textContent);
        content = `**Validation Loss**: The average loss (error) of the model on the validation dataset.\n\nThis helps assess how well the model generalizes to unseen data.\n\nCurrent value: $$ ${valLoss}$$.`;
    }

            renderInfoContent(infoElement, content);
        }


        function updateDataPlot() {
            const svg = document.getElementById('data-plot');
            const width = parseInt(svg.getAttribute('width'));
            const height = parseInt(svg.getAttribute('height'));
            // Input range
            const dataMinX = -2;
            const dataMaxX = 2;
            const dataMinY = -2;
            const dataMaxY = 2;
            const scaleX = width / 4;
            const scaleY = height / 4;

            // Clear existing content
            while (svg.firstChild) {
                svg.removeChild(svg.firstChild);
            }

            drawGrid(); // Draw the grid first
            // Plot training data
            plotDataPoints(svg, train_split, predsTrain, true);

            // Plot validation data
            plotDataPoints(svg, val_split, predsVal, false);

        }


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Display detailed info top-right
        // TODO later - selectedElement logic
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        function showInfo(event) {
            const target = event.target;
            let content = '';

            if (target.id === 'btn-play-pause' || target.id === "btn-play-pause-content") {
                if (isRunningOptimization) {
                    content = "Pause optimization";
                } else {
                    content = "Run optimization";
                }
            } else if (target.id === 'btn-fwd-backprop-update') {
                switch (optimizationStateName) {
                    case 'forward':
                        content = "**Forward pass**: run inference/prediction on the input data to produce predictions $$\\hat{y}$$ and calculate loss with respect to the true output values $$y$$.";
                        break;
                    case 'backprop':
                        // content = "**Backpropagate gradients**: Use the loss information to calculate gradients for each of the tunable weight parameters $$ W $$, starting at the end of the MLP and using the gradient information from later layers to calculate how much we should change the weights in the earlier layers. We are able to accomplish this using the chain rule from calculus ($$\\dfrac{dL}{dW_{l}} → \\dfrac{dL}{dW_{l-1}} → ... → \\dfrac{dL}{dW_{1}}$$, where $$l$$ is the number of layers in our MLP)";
                        content = "**Backpropagate gradients**: Use the loss information to calculate gradients for each of the tunable weight parameters $$ W $$, starting at the end of the MLP and using the gradient information from later layers to calculate how much we should change the weights in the earlier layers. We are able to accomplish this using the chain rule from calculus.";
                        break;
                    case 'update':
                        content = "**Update weights**: Use the gradient information to update the weights $$ W $$ of the network based on our optimization algorithm (AdamW in this case) and hyperparameters (e.g. learning rate, weight decay), with the goal of nudging this network towards better predictions of the output given the input. We also zeros out the gradients to prepare for the next step.";
                        break;
                }
            } else if (target.id === 'btn-reset-mlp') {
                content = "Reset the network parameters to randomly initialized values based on the Uniform Xavier initialization.";
            } else if (target.id === 'btn-shock-weights') {
                content = `\"Shock\" the weights: perturb the weight parameters by adding a small amount of random uniform noise between $$[-${shockNoiseScale}, ${shockNoiseScale}]$$.`;
            } else if (target.id === 'btn-step') {
                content = "Run one full epoch of the training loop and show network animations illustrating the forward pass, backpropagation of gradients, and update of the weights.";
            }
            renderInfoContent(infoElement, content);
        }


        function clearInfo(event) {
            if (!selectedElement) {
                document.getElementById('info').textContent = '';
            }
        }



        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Create figure labels
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function createLatexLabel(x, y, text, color) {
            const foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
            foreignObject.setAttribute('x', x - 75);
            foreignObject.setAttribute('y', y - 20);
            foreignObject.setAttribute('width', '150');
            foreignObject.setAttribute('height', '40');
            foreignObject.classList.add('latex-label');
            foreignObject.dataset.latex = text;

            const div = document.createElement('div');
            div.style.fontSize = LATEX_FONT_SIZE + 'px';
            div.style.color = color;
            div.style.display = 'flex';
            div.style.justifyContent = 'center';
            div.style.alignItems = 'center';
            div.style.height = '100%';

            katex.render(text, div, {
                throwOnError: false
            });

            foreignObject.appendChild(div);
            foreignObject.addEventListener('mouseover', showInfo);
            foreignObject.addEventListener('mouseout', clearInfo);
            foreignObject.addEventListener('click', showInfo);

            return foreignObject;
        }


        // function addLayerLabels() {


        function addLossLabel() {
            const lastLayerX = (layers.length + 1) * (svgWidth / (layers.length + 2));
            const braceWidth = 15;
            svg.appendChild(createLatexLabel(lastLayerX + braceWidth * 1.5 + 80, svgHeight / 2, 'L(\\hat{\\mathbf{y}}, \\mathbf{y})', LATEX_COLOR_LOSS));
        }


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Rendering events and helpers
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function renderInfoContent(element, content) {
            element.innerHTML = '';
            let currentIndex = 0;

            while (currentIndex < content.length) {
                if (content.startsWith('$$', currentIndex)) {
                    // LaTeX content
                    const endIndex = content.indexOf('$$', currentIndex + 2);
                    if (endIndex === -1) {
                        console.error('Unclosed LaTeX at position', currentIndex);
                        break;
                    }
                    const latexContent = content.slice(currentIndex + 2, endIndex);
                    const span = document.createElement('span');
                    katex.render(latexContent, span, {
                        throwOnError: false,
                        displayMode: false
                    });
                    element.appendChild(span);
                    currentIndex = endIndex + 2;
                } else if (content.startsWith('**', currentIndex)) {
                    // Bold content
                    const endIndex = content.indexOf('**', currentIndex + 2);
                    if (endIndex === -1) {
                        console.error('Unclosed bold at position', currentIndex);
                        break;
                    }
                    const boldContent = content.slice(currentIndex + 2, endIndex);
                    const strong = document.createElement('strong');
                    strong.textContent = boldContent;
                    element.appendChild(strong);
                    currentIndex = endIndex + 2;
                } else {
                    // Plain text
                    const nextSpecialChar = Math.min(
                        content.indexOf('$$', currentIndex) === -1 ? Infinity : content.indexOf('$$', currentIndex),
                        content.indexOf('**', currentIndex) === -1 ? Infinity : content.indexOf('**', currentIndex)
                    );
                    const textContent = content.slice(currentIndex, nextSpecialChar === Infinity ? undefined : nextSpecialChar);
                    const lines = textContent.split('\n');
                    lines.forEach((line, index) => {
                        element.appendChild(document.createTextNode(line));
                        if (index < lines.length - 1) {
                            element.appendChild(document.createElement('br'));
                        }
                    });
                    currentIndex = nextSpecialChar === Infinity ? content.length : nextSpecialChar;
                }
            }
        }



        function handleNodeHover(event) {
            const target = event.target;
            if (target.classList.contains('node')) {
                const layerIndex = parseInt(target.dataset.layer);
                const nodeIndex = parseInt(target.dataset.node);

                function highlightConnection(conn) {
                    conn.classList.add('highlighted');
                    conn.setAttribute('stroke-width', '3');

                    const strength = parseFloat(conn.dataset.strength);
                    const gradient = parseFloat(conn.dataset.gradient);
                    const absGradient = Math.abs(gradient);
                    const maxGradient = 1; // Adjust this value based on your gradient range

                    let color;
                    if (gradient >= 0) {
                        color = `rgba(0, 0, 255, ${absGradient / maxGradient})`;
                    } else {
                        color = `rgba(255, 0, 0, ${absGradient / maxGradient})`;
                    }

                    // conn.style.filter = `drop-shadow(0 0 3px ${color})`;
                    if (strength >= 0) {
                        conn.classList.add('positive');
                        conn.classList.remove('negative');
                    } else {
                        conn.classList.add('negative');
                        conn.classList.remove('positive');
                    }
                }

                // Highlight incoming connections
                if (layerIndex > 0) {
                    const incomingConnections = document.querySelectorAll(`.connection[data-to="${layerIndex},${nodeIndex}"]`);
                    incomingConnections.forEach(highlightConnection);
                }

                // Highlight outgoing connections
                if (layerIndex < layers.length - 1) {
                    const outgoingConnections = document.querySelectorAll(`.connection[data-from="${layerIndex},${nodeIndex}"]`);
                    outgoingConnections.forEach(highlightConnection);
                }
            }
        }


        function resetNodeHover() {
            // if (selectedElement) return; // Don't reset if there's a selected element
            const highlightedConnections = document.querySelectorAll('.connection.highlighted');
            highlightedConnections.forEach(conn => {
                conn.classList.remove('highlighted', 'positive', 'negative');
                conn.setAttribute('stroke-width', '1');
                conn.style.filter = '';
            });
        }


        function resetConnectionAppearance(event) {
            const target = event.target;

            if (target.classList.contains('connection')) {
                target.style.filter = '';
                target.classList.remove('highlighted', 'positive', 'negative');
            }
        }


        function updateConnectionOpacity() {
            const connections = document.querySelectorAll('.connection');
            connections.forEach(connection => {
                if (showConnectionStrengthOpacity) {
                    const strength = parseFloat(connection.dataset.strength);
                    const maxStrength = parseFloat(connection.dataset.maxStrength);
                    const opacity = strength / maxStrength;
                    connection.setAttribute('stroke-opacity', opacity);
                } else {
                    connection.setAttribute('stroke-opacity', 1);
                }
            });
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Animations
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        // after micrograd implemented: nodes act as accumulators and change color and intensity based
        // on weighted input and activation function
        function animateForwardPass() { }

        function animateBackwardPass() { }

        function animateUpdateWeights() { }

        function animateShockWeights() { }


        function resetTrainingDisplay() {
            document.getElementById('epoch-display').textContent = `Epoch: 0`;
            document.getElementById('train-loss-value').textContent = 'N/A';
            document.getElementById('val-loss-value').textContent = 'N/A';
        }


        function updateTrainingDisplay(epochVal, trainLoss, valLoss) {
            document.getElementById('epoch-display').textContent = `Epoch: ${epochVal}`;
            if (trainLoss !== null) {
                document.getElementById('train-loss-value').textContent = trainLoss.toFixed(20);
            }
            if (valLoss !== null) {
                document.getElementById('val-loss-value').textContent = valLoss.toFixed(20);
            }
        }



        function logMessage(message) {
            const logContainer = document.getElementById('log-container');
            logContainer.innerHTML += `<p>${message}</p>`;
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Random Number Generation
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        class RNG {
            constructor(seed) {
                this.state = BigInt(seed);
            }

            random_u32() {
                // xorshift rng: https://en.wikipedia.org/wiki/Xorshift#xorshift.2A
                this.state = BigInt.asUintN(64, this.state);
                this.state ^= (this.state >> 12n) & 0xFFFFFFFFFFFFFFFFn;
                this.state ^= (this.state << 25n) & 0xFFFFFFFFFFFFFFFFn;
                this.state ^= (this.state >> 27n) & 0xFFFFFFFFFFFFFFFFn;

                return Number((this.state * 0x2545F4914F6CDD1Dn >> 32n) & 0xFFFFFFFFn);
            }

            random() {
                // random Number in [0, 1)
                return (this.random_u32() >>> 8) / 16777216.0;
            }

            uniform(a = 0.0, b = 1.0) {
                // random Number in [a, b)
                return a + (b - a) * this.random();
            }
        }

        function gen_data(random, n = 100) {
            let pts = [];
            for (let i = 0; i < n; i++) {
                let x = random.uniform(-2.0, 2.0);
                let y = random.uniform(-2.0, 2.0);
                // concentric circles
                // label = 0 if x**2 + y**2 < 1 else 1 if x**2 + y**2 < 2 else 2
                // very simple dataset
                let label = x < 0 ? 0 : y < 0 ? 1 : 2;
                pts.push([[x, y], label]);
            }
            // create train/val/test splits of the data (80%, 10%, 10%)
            let tr = pts.slice(0, Math.floor(0.8 * n));
            let val = pts.slice(Math.floor(0.8 * n), Math.floor(0.9 * n));
            let te = pts.slice(Math.floor(0.9 * n));
            return [tr, val, te];
        }


        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Micrograd MLP
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        class Value {
            // stores a single scalar value and its gradient
            constructor(data, _children = [], _op = '') {
                this.data = data;
                this.grad = 0;
                this._backward = () => { };
                this._prev = new Set(_children);
                this._op = _op;
            }

            add(other) {
                other = other instanceof Value ? other : new Value(other);
                const out = new Value(this.data + other.data, [this, other], '+');
                out._backward = () => {
                    this.grad += out.grad;
                    other.grad += out.grad;
                };

                return out;
            }

            mul(other) {
                other = other instanceof Value ? other : new Value(other);
                const out = new Value(this.data * other.data, [this, other], '*');
                out._backward = () => {
                    this.grad += other.data * out.grad;
                    other.grad += this.data * out.grad;
                };

                return out;
            }

            pow(other) {
                if (typeof other !== 'number') throw new Error("only supporting number powers for now");
                const out = new Value(Math.pow(this.data, other), [this], `**${other}`);

                out._backward = () => {
                    this.grad += other * Math.pow(this.data, other - 1) * out.grad;
                };

                return out;
            }

            relu() {
                const out = new Value(this.data < 0 ? 0 : this.data, [this], 'ReLU');
                out._backward = () => {
                    this.grad += (out.data > 0) * out.grad;
                };

                return out;
            }

            tanh() {
                const x = Math.tanh(this.data);
                const out = new Value(x, [this], 'tanh');
                out._backward = () => {
                    this.grad += (1 - x * x) * out.grad;
                };

                return out;
            }

            exp() {
                const x = Math.exp(this.data);
                const out = new Value(x, [this], 'exp');
                out._backward = () => {
                    this.grad += x * out.grad;
                };

                return out;
            }

            log() {
                const out = new Value(Math.log(this.data), [this], 'log');
                out._backward = () => {
                    this.grad += (1 / this.data) * out.grad;
                };

                return out;
            }

            backward() {
                const topo = [];
                const visited = new Set();

                function buildTopo(v) {
                    if (!visited.has(v)) {
                        visited.add(v);
                        for (const child of v._prev) {
                            buildTopo(child);
                        }
                        topo.push(v);
                    }
                }

                buildTopo(this);

                this.grad = 1;
                for (const v of topo.reverse()) {
                    v._backward();
                }
            }

            neg() { return this.mul(-1); }
            sub(other) { return this.add(other instanceof Value ? other.neg() : new Value(-other)); }
            div(other) { return this.mul(other instanceof Value ? other.pow(-1) : new Value(Math.pow(other, -1))); }

            toString() {
                return `Value(data=${this.data}, grad=${this.grad})`;
            }
        }


        class Module {
            zeroGrad() {
                for (const p of this.parameters()) {
                    p.grad = 0;
                }
            }

            parameters() {
                return [];
            }
        }

        class Neuron extends Module {
            constructor(nin, kwargs) {
                super();
                this.w = Array(nin).fill().map(() => new Value(random.uniform(-1, 1) * Math.pow(nin, -0.5)));
                this.b = new Value(0);
                this.nonlin = kwargs.nonlin !== undefined ? kwargs.nonlin : true;
            }

            call(x) {
                const act = this.w.reduce((sum, wi, i) => sum.add(wi.mul(x[i])), this.b);
                return this.nonlin ? act.tanh() : act;
            }

            parameters() {
                return [...this.w, this.b];
            }

            toString() {
                return `${this.nonlin ? 'TanH' : 'Linear'}Neuron(${this.w.length})`;
            }
        }

        class Layer extends Module {
            constructor(nin, nout, kwargs = {}) {
                super();
                this.neurons = Array(nout).fill().map(() => new Neuron(nin, kwargs));
            }

            call(x) {
                const out = this.neurons.map(n => n.call(x));
                return out.length === 1 ? out[0] : out;
            }

            parameters() {
                return this.neurons.flatMap(n => n.parameters());
            }

            toString() {
                return `Layer of [${this.neurons.join(', ')}]`;
            }
        }

        class MLP extends Module {
            constructor(nin, nouts) {
                super();
                const sz = [nin, ...nouts];
                this.layers = sz.slice(0, -1).map((s, i) => new Layer(s, sz[i + 1], { nonlin: i !== nouts.length - 1 }));

            }

            call(x) {
                for (const layer of this.layers) {
                    x = layer.call(x);
                    x = Array.isArray(x) ? x : [x]
                }
                return x
            }

            parameters() {
                return this.layers.flatMap(l => l.parameters());
            }

            toString() {
                return `MLP of [${this.layers.join(', ')}]`;
            }

            shockWeights() {
                for (const layer of this.layers) {
                    for (const neuron of layer.neurons) {
                        for (const w of neuron.w) {
                            const noise = random.uniform(-shockNoiseScale, shockNoiseScale);
                            w.data += noise;
                        }
                        const bias_noise = random.uniform(-shockNoiseScale, shockNoiseScale);
                        neuron.b.data += bias_noise;
                    }
                }
            }
        }

        function crossEntropy(logits, target) {
            // subtract the max for numerical stability (avoids overflow)
            const maxVal = Math.max(...logits.map(v => v.data));
            const shiftedLogits = logits.map(v => v.sub(maxVal));
            // 1) evaluate elementwise e^x
            const ex = shiftedLogits.map(x => x.exp());
            // 2) compute the sum of the above
            const denom = ex.reduce((sum, x) => sum.add(x));
            // 3) normalize by the sum to get probabilities
            const probs = ex.map(x => x.div(denom));
            // 4) log the probabilities at target
            const logp = probs[target].log();
            // 5) the negative log likelihood loss (invert so we get a loss - lower is better)
            const nll = logp.neg();
            return nll;
        }

        // evaluation utility to compute the loss on a given split of the dataset
        function evalSplit(model, split) {
            // evaluate the loss of a split
            let loss = new Value(0);
            // track for plotting
            logitsVal = [];
            predsVal = [];
            for (const [x, y] of split) {
                const logits = model.call([new Value(x[0]), new Value(x[1])]);
                logitsVal.push(logits);
                predsVal.push(argmax(logits.map(v => v.data)));
                loss = loss.add(crossEntropy(logits, y));
            }
            loss = loss.mul(1.0 / split.length); // normalize the loss
            return loss.data;
        }

        function trainForward() {
            // forward pass
            if (epoch % 10 === 0) {
                const val_loss = evalSplit(mlp, val_split);
                updateTrainingDisplay(epoch, null, val_loss);
            }

            loss = new Value(0);
            // track for plotting
            logitsTrain = [];
            predsTrain = [];
            for (const [x, y] of train_split) {
                const logits = mlp.call([new Value(x[0]), new Value(x[1])]);
                logitsTrain.push(logits);
                predsTrain.push(argmax(logits.map(v => v.data)));
                loss = loss.add(crossEntropy(logits, y));
            }
            loss = loss.mul(1.0 / train_split.length);
            updateTrainingDisplay(epoch, loss.data, null);

            updateDataPlot();
        }

        function trainBackward() {
            // backward pass (deposit the gradients)
            loss.backward();
        }

        function trainUpdate() {
            // update with AdamW
            for (const p of mlp.parameters()) {
                p.m = beta1 * p.m + (1 - beta1) * p.grad;
                p.v = beta2 * p.v + (1 - beta2) * Math.pow(p.grad, 2);
                const m_hat = p.m / (1 - Math.pow(beta1, epoch + 1));
                const v_hat = p.v / (1 - Math.pow(beta2, epoch + 1));
                p.data -= learning_rate * (m_hat / (Math.sqrt(v_hat) + eps) + weight_decay * p.data);
            }
            mlp.zeroGrad();
            updateTrainingDisplay(epoch, loss.data, null);

            epoch++;
        }

        function trainModelStep(stage, fullStep = false) {
            if (!mlp) {
                console.error("MLP not initialized");
                return;
            }

            if (fullStep) {
                resetCurrentTrainingStage();
                trainForward();
                trainBackward();
                trainUpdate();
            } else {
                switch (stage) {
                    case 0: // Forward pass
                        trainForward();
                        break;

                    case 1: // Backward pass
                        trainBackward();
                        break;
                    case 2: // Update
                        trainUpdate();
                        break;
                }
                currentTrainingStage = (stage + 1) % 3;
                updateButtonState(btnFwdBackUp, currentTrainingStage);
            }
        }

        function trainModel(state) {
            function trainingLoop() {
                if (!isRunningOptimization) return;

                trainModelStep(state, true);

                if (currentTrainingStage === 0) {
                    // We've completed a full cycle, request the next frame
                    requestAnimationFrame(trainingLoop);
                } else {
                    // We're in the middle of a cycle, continue immediately
                    trainingLoop();
                }
            }
            trainingLoop();
        }

        function updateButtonState(button, stage) {
            switch (stage) {
                case 0:
                    button.textContent = '→';
                    optimizationStateName = 'forward';
                    break;
                case 1:
                    button.textContent = '←';
                    optimizationStateName = 'backprop';
                    break;
                case 2:
                    button.textContent = '↑';
                    optimizationStateName = 'update';
                    break;
            }
        }

        function resetCurrentTrainingStage() {
            // in case we are partway through a cycle, reset stage and grad
            currentTrainingStage = 0;
            mlp.zeroGrad();
            updateButtonState(btnFwdBackUp, currentTrainingStage);
        }

        function argmax(array) {
            if (array.length === 0) {
                return -1; // Return -1 for empty array
            }

            const max = Math.max(...array);
            return array.indexOf(max);
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Add event listeners and draw
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        const random = new RNG(42);

        svg.addEventListener('click', function (event) {
            showInfo(event);
        });

        function addEventListeners(element) {
            element.addEventListener('mouseover', showInfo);
            element.addEventListener('mouseout', clearInfo);
            element.addEventListener('click', showInfo);
        }

        function addReportingContainerListeners() {
            document.getElementById('epoch-display').addEventListener('mouseover', showReportingInfo);
            document.getElementById('epoch-display').addEventListener('mouseout', clearInfo);

            document.getElementById('train-loss-display').addEventListener('mouseover', showReportingInfo);
            document.getElementById('train-loss-display').addEventListener('mouseout', clearInfo);

            document.getElementById('val-loss-display').addEventListener('mouseover', showReportingInfo);
            document.getElementById('val-loss-display').addEventListener('mouseout', clearInfo);
        }

        document.querySelectorAll('.node, .connection, .layer, .latex-label').forEach(addEventListeners);

        btnPlayPause.addEventListener('click', function (event) {
            isRunningOptimization = !isRunningOptimization;
            this.querySelector('span').textContent = isRunningOptimization ? '⏸' : '▶';

            if (isRunningOptimization) {
                trainModel(currentTrainingStage);
            }

            const buttonsDisableRunning = ['btn-reset-mlp', 'btn-shock-weights', 'btn-step', 'btn-fwd-backprop-update'];
            buttonsDisableRunning.forEach(id => {
                const button = document.getElementById(id);
                button.disabled = isRunningOptimization;
            });
            showInfo(event);
        });

        btnStep.addEventListener('click', function () {
            trainModelStep(currentTrainingStage, true);
            updateButtonState(btnFwdBackUp, currentTrainingStage);
            showInfo({ target: this });
        });

        btnFwdBackUp.addEventListener('click', function () {
            trainModelStep(currentTrainingStage, false);
            updateButtonState(this, currentTrainingStage);
            showInfo({ target: this });
        });

        btnResetMLP.addEventListener('click', function () {
            resetMLP();
        });

        document.getElementById('btn-shock-weights').addEventListener('click', function () {
            mlp.shockWeights();
        });

        // Add mouseover and mouseout event listeners for the new buttons
        ['btn-reset-mlp', 'btn-shock-weights', 'btn-step', 'btn-fwd-backprop-update', 'btn-play-pause'].forEach(id => {
            const button = document.getElementById(id);
            button.addEventListener('mouseover', showInfo);
            button.addEventListener('mouseout', clearInfo);
        });

        // drawNetwork();
        window.onload = function () {
            document.getElementById('layerDimInput').value = initialHidden;
            resetData();
            resetMLP();
            addReportingContainerListeners();
        };

    </script>
</body>

</html>